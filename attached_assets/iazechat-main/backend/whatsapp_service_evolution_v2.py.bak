"""
Servi√ßo WhatsApp Evolution API V2
Gerencia inst√¢ncias, QR codes e mensagens via Evolution API V2.2.3
"""
import httpx
import os
import asyncio
from datetime import datetime, timezone
from typing import Optional, Dict, List
import logging
import uuid

logger = logging.getLogger(__name__)

class WhatsAppServiceEvolutionV2:
    """Servi√ßo para gerenciar WhatsApp Evolution API V2"""
    
    def __init__(self, db):
        self.db = db
        self.connections_col = db.whatsapp_connections
        self.configs_col = db.whatsapp_configs
        self.messages_col = db.whatsapp_messages
        
        # Evolution API V2 configuration
        self.EVOLUTION_URL = os.environ.get('EVOLUTION_API_URL', 'http://151.243.218.223:9000')
        self.EVOLUTION_API_KEY = os.environ.get('EVOLUTION_API_KEY', 'iaze-evolution-2025-secure-key')
        
        print(f"üîß WhatsAppServiceEvolutionV2 inicializado com Evolution API: {self.EVOLUTION_URL}", flush=True)
        logger.info(f"üîß WhatsAppServiceEvolutionV2 inicializado com Evolution API: {self.EVOLUTION_URL}")
    
    # ==================== GERENCIAMENTO DE INST√ÇNCIAS ====================
    
    async def create_instance(self, reseller_id: str, name: str, phone_number: Optional[str] = None) -> Dict:
        """
        Criar uma nova inst√¢ncia WhatsApp na Evolution API V2
        
        Args:
            reseller_id: ID do revendedor
            name: Nome da inst√¢ncia (√∫nico)
            phone_number: N√∫mero de telefone (opcional)
        
        Returns:
            Dict com resultado da cria√ß√£o
        """
        try:
            # Gerar nome √∫nico da inst√¢ncia com timestamp
            timestamp = int(datetime.now(timezone.utc).timestamp())
            instance_name = f"{name}_{timestamp}"
            
            logger.info(f"üì§ Criando inst√¢ncia Evolution API: {instance_name}")
            
            # Payload para Evolution API V2.3.0
            payload = {
                "instanceName": instance_name,
                "integration": "WHATSAPP-BAILEYS",
                "qrcode": True
            }
            
            # Se tiver n√∫mero de telefone, adicionar
            if phone_number:
                payload["number"] = phone_number.replace("+", "").replace("-", "").replace(" ", "")
            
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.post(
                    f"{self.EVOLUTION_URL}/instance/create",
                    json=payload,
                    headers={
                        "apikey": self.EVOLUTION_API_KEY,
                        "Content-Type": "application/json"
                    }
                )
                
                logger.info(f"üì• Response status: {response.status_code}")
                logger.info(f"üì• Response body: {response.text[:500]}")
                
                if response.status_code in [200, 201]:
                    data = response.json()
                    logger.info(f"‚úÖ Inst√¢ncia criada: {data}")
                    
                    # Agora buscar o QR code com GET /instance/connect/{instance}
                    qr_code = None
                    qr_code_base64 = None
                    
                    try:
                        qr_response = await client.get(
                            f"{self.EVOLUTION_URL}/instance/connect/{instance_name}",
                            headers={"apikey": self.EVOLUTION_API_KEY}
                        )
                        
                        if qr_response.status_code == 200:
                            qr_data = qr_response.json()
                            qr_code = qr_data.get("code")
                            qr_code_base64 = qr_data.get("base64")
                            logger.info(f"‚úÖ QR code obtido para {instance_name}")
                    except Exception as qr_error:
                        logger.warning(f"‚ö†Ô∏è Erro ao obter QR code: {qr_error}")
                    
                    # Salvar conex√£o no banco de dados
                    connection_id = str(uuid.uuid4())
                    connection_doc = {
                        "id": connection_id,
                        "reseller_id": reseller_id,
                        "name": name,
                        "instance_name": instance_name,
                        "phone_number": phone_number,
                        "status": "connecting",
                        "qr_code": qr_code,
                        "qr_code_base64": qr_code_base64,
                        "created_at": datetime.now(timezone.utc),
                        "updated_at": datetime.now(timezone.utc),
                        "api_type": "evolution_v1"
                    }
                    
                    await self.connections_col.insert_one(connection_doc)
                    logger.info(f"‚úÖ Inst√¢ncia criada no DB: {connection_id}")
                    
                    return {
                        "success": True,
                        "connection_id": connection_id,
                        "instance_name": instance_name,
                        "status": "connecting",
                        "qr_code": qr_code,
                        "qr_code_base64": qr_code_base64,
                        "message": "Inst√¢ncia criada com sucesso!"
                    }
                else:
                    error_msg = f"Evolution API erro {response.status_code}: {response.text}"
                    logger.error(f"‚ùå {error_msg}")
                    return {
                        "success": False,
                        "message": error_msg
                    }
                    
        except Exception as e:
            logger.error(f"‚ùå Erro ao criar inst√¢ncia: {str(e)}", exc_info=True)
            return {
                "success": False,
                "message": f"Erro ao criar inst√¢ncia: {str(e)}"
            }
    
    async def get_qr_code(self, connection_id: str) -> Dict:
        """
        Obter QR code de uma conex√£o
        
        Args:
            connection_id: ID da conex√£o no banco
        
        Returns:
            Dict com QR code e status
        """
        try:
            # Buscar conex√£o no banco
            connection = await self.connections_col.find_one({"id": connection_id})
            
            if not connection:
                return {
                    "success": False,
                    "message": "Conex√£o n√£o encontrada"
                }
            
            instance_name = connection["instance_name"]
            
            logger.info(f"üîç Buscando QR code para: {instance_name}")
            
            # Buscar QR code na Evolution API
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(
                    f"{self.EVOLUTION_URL}/instance/connect/{instance_name}",
                    headers={"apikey": self.EVOLUTION_API_KEY}
                )
                
                if response.status_code == 200:
                    data = response.json()
                    
                    qr_code = data.get("code") or data.get("qrcode", {}).get("code")
                    qr_code_base64 = data.get("base64") or data.get("qrcode", {}).get("base64")
                    
                    # Atualizar no banco se tiver QR code novo
                    if qr_code or qr_code_base64:
                        await self.connections_col.update_one(
                            {"id": connection_id},
                            {
                                "$set": {
                                    "qr_code": qr_code,
                                    "qr_code_base64": qr_code_base64,
                                    "updated_at": datetime.now(timezone.utc)
                                }
                            }
                        )
                    
                    return {
                        "success": True,
                        "qr_code": qr_code,
                        "qr_code_base64": qr_code_base64,
                        "status": connection.get("status", "connecting")
                    }
                else:
                    logger.error(f"‚ùå Erro ao buscar QR: {response.status_code} - {response.text}")
                    return {
                        "success": False,
                        "message": f"Erro ao buscar QR code: {response.status_code}"
                    }
                    
        except Exception as e:
            logger.error(f"‚ùå Erro ao obter QR code: {str(e)}", exc_info=True)
            return {
                "success": False,
                "message": f"Erro ao obter QR code: {str(e)}"
            }
    
    async def check_connection_status(self, connection_id: str) -> Dict:
        """
        Verificar status de conex√£o de uma inst√¢ncia
        
        Args:
            connection_id: ID da conex√£o
        
        Returns:
            Dict com status atualizado
        """
        try:
            # Buscar conex√£o no banco
            connection = await self.connections_col.find_one({"id": connection_id})
            
            if not connection:
                return {
                    "success": False,
                    "message": "Conex√£o n√£o encontrada"
                }
            
            instance_name = connection["instance_name"]
            
            logger.info(f"üîç Verificando status de: {instance_name}")
            
            # Verificar status na Evolution API
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(
                    f"{self.EVOLUTION_URL}/instance/fetchInstances",
                    headers={"apikey": self.EVOLUTION_API_KEY},
                    params={"instanceName": instance_name}
                )
                
                if response.status_code == 200:
                    instances = response.json()
                    
                    # Buscar a inst√¢ncia espec√≠fica
                    instance_data = None
                    if isinstance(instances, list):
                        for inst in instances:
                            if inst.get("instance", {}).get("instanceName") == instance_name:
                                instance_data = inst
                                break
                    
                    if instance_data:
                        state = instance_data.get("instance", {}).get("state", "connecting")
                        
                        # Mapear estados da Evolution API
                        status_map = {
                            "open": "connected",
                            "connecting": "connecting",
                            "close": "disconnected"
                        }
                        status = status_map.get(state, "connecting")
                        
                        # Atualizar no banco
                        await self.connections_col.update_one(
                            {"id": connection_id},
                            {
                                "$set": {
                                    "status": status,
                                    "updated_at": datetime.now(timezone.utc)
                                }
                            }
                        )
                        
                        logger.info(f"‚úÖ Status atualizado: {status}")
                        
                        return {
                            "success": True,
                            "status": status,
                            "instance_name": instance_name
                        }
                    else:
                        return {
                            "success": False,
                            "message": "Inst√¢ncia n√£o encontrada na Evolution API"
                        }
                else:
                    logger.error(f"‚ùå Erro ao verificar status: {response.status_code}")
                    return {
                        "success": False,
                        "message": f"Erro ao verificar status: {response.status_code}"
                    }
                    
        except Exception as e:
            logger.error(f"‚ùå Erro ao verificar status: {str(e)}", exc_info=True)
            return {
                "success": False,
                "message": f"Erro ao verificar status: {str(e)}"
            }
    
    async def delete_instance(self, connection_id: str) -> Dict:
        """
        Deletar uma inst√¢ncia da Evolution API e do banco
        
        Args:
            connection_id: ID da conex√£o
        
        Returns:
            Dict com resultado da dele√ß√£o
        """
        try:
            # Buscar conex√£o no banco
            connection = await self.connections_col.find_one({"id": connection_id})
            
            if not connection:
                return {
                    "success": False,
                    "message": "Conex√£o n√£o encontrada"
                }
            
            instance_name = connection["instance_name"]
            
            logger.info(f"üóëÔ∏è Deletando inst√¢ncia: {instance_name}")
            
            # Deletar da Evolution API
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.delete(
                    f"{self.EVOLUTION_URL}/instance/delete/{instance_name}",
                    headers={"apikey": self.EVOLUTION_API_KEY}
                )
                
                logger.info(f"üì• Delete response: {response.status_code}")
                
                # Deletar do banco (mesmo se a API falhar)
                await self.connections_col.delete_one({"id": connection_id})
                
                if response.status_code in [200, 204]:
                    return {
                        "success": True,
                        "message": "Inst√¢ncia deletada com sucesso"
                    }
                else:
                    return {
                        "success": True,  # Ainda sucesso pois deletou do DB
                        "message": f"Inst√¢ncia deletada do banco. API retornou: {response.status_code}"
                    }
                    
        except Exception as e:
            logger.error(f"‚ùå Erro ao deletar inst√¢ncia: {str(e)}", exc_info=True)
            return {
                "success": False,
                "message": f"Erro ao deletar inst√¢ncia: {str(e)}"
            }
    
    async def list_connections(self, reseller_id: str) -> List[Dict]:
        """
        Listar todas as conex√µes de um revendedor
        
        Args:
            reseller_id: ID do revendedor
        
        Returns:
            Lista de conex√µes
        """
        try:
            connections = await self.connections_col.find(
                {"reseller_id": reseller_id, "api_type": "evolution_v2"}
            ).to_list(length=100)
            
            # Remover _id do MongoDB para serializa√ß√£o JSON
            for conn in connections:
                conn.pop("_id", None)
            
            return connections
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao listar conex√µes: {str(e)}")
            return []
    
    async def send_message(self, instance_name: str, phone_number: str, message: str) -> Dict:
        """
        Enviar mensagem via Evolution API
        
        Args:
            instance_name: Nome da inst√¢ncia
            phone_number: N√∫mero do destinat√°rio
            message: Texto da mensagem
        
        Returns:
            Dict com resultado do envio
        """
        try:
            # Formatar n√∫mero de telefone (adicionar @s.whatsapp.net se necess√°rio)
            if "@" not in phone_number:
                phone_number = f"{phone_number}@s.whatsapp.net"
            
            payload = {
                "number": phone_number,
                "text": message
            }
            
            logger.info(f"üì§ Enviando mensagem via {instance_name}")
            
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.post(
                    f"{self.EVOLUTION_URL}/message/sendText/{instance_name}",
                    json=payload,
                    headers={
                        "apikey": self.EVOLUTION_API_KEY,
                        "Content-Type": "application/json"
                    }
                )
                
                if response.status_code in [200, 201]:
                    data = response.json()
                    return {
                        "success": True,
                        "message_id": data.get("key", {}).get("id"),
                        "data": data
                    }
                else:
                    return {
                        "success": False,
                        "message": f"Erro ao enviar mensagem: {response.status_code}"
                    }
                    
        except Exception as e:
            logger.error(f"‚ùå Erro ao enviar mensagem: {str(e)}")
            return {
                "success": False,
                "message": f"Erro ao enviar mensagem: {str(e)}"
            }
